<!doctype html>
<html lang="en">
  <head>
    <script type="text/javascript">
      var clients = {};
      var options = {};
      
      // stored as hash for faster searching
      var blocked_hosts = {};
      
      window.addEventListener('load', setupConnection, false);
      
      function setupConnection(){
        // When the injected script is activated, it connects with the background process.
        opera.extension.onconnect = function(event){
          event.source.postMessage({what: 'id', name: 'background'});
        }
        opera.extension.ondisconnect = function(event) {
          // remove client from list
          for(var type in clients) {
            var i = clients[type].indexOf(event.source);
            if(i >= 0) {
              //opera.postError('back: removing client ' + event.origin);
              clients[type].splice(i,1);
            } else {
              // Unfortunatelly opera doesn't provide event.source when a
              // client disconnects. This makes it hard to keep track of
              // connected clients.
              //opera.postError('back: disconnect without remove ' + event.origin + ', ' + event.source);
            }
          }
        }
        
        opera.extension.onmessage = handle_message;
      }
      
      function handle_message(event) {
        switch(event.data['what']) {
          case 'id':
            // add client to list of clients
            if(!clients[event.data['name']]) clients[event.data['name']] = [];
            clients[event.data['name']].push(event.source);
            
            break;
          case 'get blocked hosts':
            event.source.postMessage({
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            
            break;
          case 'check hosts':
            // Get list of received hosts which should be blocked
            var list = event.data['hosts'].filter(function(host) {
              return !!options['blocked_hosts'][host];
            });
            
            // notify userjs about which hosts to block
            event.source.postMessage({
              what: 'block hosts',
              list: list
            });
            
            break;
          case 'block hosts':
            var hosts = event.data['list'].map(function(host) {
              return host.toLowerCase();
            }).filter(function(host) {
              var idx = host.search(/[*]/);
              return host.length > 2 && idx == -1;
            });
            
            hosts.forEach(function(host) {
              options['blocked_hosts'][host] = true;
            });
            
            // make it persist
            save_option('blocked_hosts');
            
            // tell userjs to block this host
            message_clients('userjs',{
              what: 'block hosts',
              list: hosts
            });
            
            // update any open options pages
            message_clients('options', {
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            
            break;
          case 'unblock hosts':
            event.data['list'].forEach(function(host) {
              delete options['blocked_hosts'][host]
            });
            save_option('blocked_hosts');
            
            // update any open options pages
            message_clients('options', {
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            
            // unblock results on any open google search pages
            message_clients('userjs', {
              what: 'unblock hosts',
              list: event.data['list']
            });
            
            break;
          case 'get option':
            event.source.postMessage({
              what: 'option',
              name: event.data['name'],
              value: options[event.data['name']]
            });
            
            break;
          case 'set option':
            var name = event.data['name'];
            set_option(name, event.data['value']);
            save_option(name);
            
            switch(name) {
              case 'confirm_block':
                // alert userjs of the change
                message_clients('userjs',{
                  what: 'option',
                  name: 'confirm_block',
                  value: options[name]
                });
                break;
            }
            
            break;
        }
      }
      
      function message_clients(type, data) {
        if(clients[type]) {
          clients[type].forEach(function(source) {
            try {
              source.postMessage(data);
            } catch(e) {
              // The ondisconnect event should provide us with a source
              // however opera sets source to null.
              // This is an ugly work around.
              delete clients[type][source];
            }
          });
        }
      }
      
      // as an array
      function get_blocked_hosts_list() {
        var list = [];
        for(var host in options['blocked_hosts']) { list.push(host); }
        return list;
      }
      
      // hosts: hash of blocked hosts
      function save_blocked_hosts(hosts) {
        widget.preferences.setItem('blocked hosts', JSON.stringify(hosts));
      }
      
      function set_option(name, value) {
        options[name] = value;
      }
      
      function save_option(name) {
        widget.preferences.setItem(name, JSON.stringify(options[name]));
      }
      
      function load_options() {
        var a, key;
        for(a = 0; a < widget.preferences.length; a++) {
          key = widget.preferences.key(a);
          options[key] = JSON.parse(widget.preferences.getItem(key));
        }
        
        // Incase options are not imported properly
        if(typeof options['blocked_hosts'] == 'undefined') options['blocked_hosts'] = {};
        if(typeof options['confirm_block'] == 'undefined') options['confirm_block'] = false;
      }
      
      function save_options() {
        for(key in options) {
          widget.preferences.setItem(key,JSON.stringify(options[key]));
        }
      }
      
      load_options();
    </script>
  </head>
  <body>
  </body>
</html>
