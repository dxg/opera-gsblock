<!doctype html>
<html lang="en">
  <head>
    <script type="text/javascript">
      /*
       * This is the backend worker of the extension.
       * All communication in/out is handled via html5 web messaging.
       */
      
      // Hash of all connected clients by type.
      // Eg. {options: [client], userjs: [client1, client2]}
      var clients = {};
      
      // A local variable cache of all options in the extensions local storage
      var options = {};
      
      // When this extension has loaded, listen for connections
      window.addEventListener('load', setup_connection, false);
      
      /*
       * Initializes & logs all connections & disconnections
       */
      function setup_connection(){
        // When the injected script is activated, it connects with the background process.
        opera.extension.onconnect = function(event){
          event.source.postMessage({what: 'id', name: 'background'});
        }
        opera.extension.ondisconnect = function(event) {
          // remove client from list
          for(var type in clients) {
            var i = clients[type].indexOf(event.source);
            if(i >= 0) {
              //opera.postError('back: removing client ' + event.origin);
              clients[type].splice(i,1);
            } else {
              // Unfortunatelly opera doesn't provide event.source when a
              // client disconnects. This makes it hard to keep track of
              // connected clients.
              //opera.postError('back: disconnect without remove ' + event.origin + ', ' + event.source);
            }
          }
        }
        
        opera.extension.onmessage = handle_message;
      }
      
      /*
       * Handles all incoming messages from both options & userjs scripts
       */
      function handle_message(event) {
        switch(event.data['what']) {
          case 'id':
            // add client to list of clients
            if(!clients[event.data['name']]) clients[event.data['name']] = [];
            clients[event.data['name']].push(event.source);
            break;
          
          case 'get blocked hosts':
            event.source.postMessage({
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            break;
          
          case 'check hosts':
            // Get list of received hosts which should be blocked
            var list = event.data['hosts'].filter(function(host) {
              return !!options['blocked_hosts'][host];
            });
            
            // notify userjs about which hosts to block
            event.source.postMessage({
              what: 'block hosts',
              list: list
            });
            break;
          
          case 'block hosts':
            var hosts = event.data['list'].map(function(host) {
              return host.toLowerCase();
            }).filter(function(host) {
              var idx = host.search(/[*]/);
              return host.length > 2 && idx == -1;
            });
            
            hosts.forEach(function(host) {
              options['blocked_hosts'][host] = true;
            });
            
            // make it persist
            save_option('blocked_hosts');
            
            // tell userjs to block this host
            message_clients('userjs',{
              what: 'block hosts',
              list: hosts
            });
            
            // update any open options pages
            message_clients('options', {
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            break;
          
          case 'unblock hosts':
            event.data['list'].forEach(function(host) {
              delete options['blocked_hosts'][host]
            });
            save_option('blocked_hosts');
            
            // update any open options pages
            message_clients('options', {
              what: 'all blocked hosts',
              list: get_blocked_hosts_list()
            });
            
            // unblock results on any open google search pages
            message_clients('userjs', {
              what: 'unblock hosts',
              list: event.data['list']
            });
            break;
          
          case 'get option':
            event.source.postMessage({
              what: 'option',
              name: event.data['name'],
              value: options[event.data['name']]
            });
            break;
          
          case 'set option':
            var name = event.data['name'];
            set_option(name, event.data['value']);
            save_option(name);
            
            switch(name) {
              case 'confirm_block':
                // alert userjs of the change
                message_clients('userjs',{
                  what: 'option',
                  name: 'confirm_block',
                  value: options[name]
                });
                break;
            }
            break;
        }
      }
      
      /*
       * Sends a message to all clients of a particular type
       *
       * type: client type, one of ['options','userjs]
       * data: javascript hash-like object containing the data
       */
      function message_clients(type, data) {
        if(clients[type]) {
          clients[type].forEach(function(source) {
            try {
              source.postMessage(data);
            } catch(e) {
              // The ondisconnect event should provide us with a source
              // however opera sets source to null.
              // This is an ugly work around.
              delete clients[type][source];
            }
          });
        }
      }
      
      /*
       * Returns a list of blocked hosts in an array.
       * Normally it's stored as a hash for speed.
       */
      function get_blocked_hosts_list() {
        var list = [];
        for(var host in options['blocked_hosts']) { list.push(host); }
        return list;
      }
      
      /*
       * Sets the value of an option
       */
      function set_option(name, value) {
        options[name] = value;
      }
      
      /*
       * Saves a particular option to the widgets local storage
       */
      function save_option(name) {
        widget.preferences.setItem(name, JSON.stringify(options[name]));
      }
      
      /*
       * Loads all options into a local variable from the widgets local storage.
       */
      function load_options() {
        var a, key;
        for(a = 0; a < widget.preferences.length; a++) {
          key = widget.preferences.key(a);
          options[key] = JSON.parse(widget.preferences.getItem(key));
        }
        
        // Incase options are not imported properly
        if(typeof options['blocked_hosts'] == 'undefined') options['blocked_hosts'] = {};
        if(typeof options['confirm_block'] == 'undefined') options['confirm_block'] = false;
      }
      
      /*
       * Saves all options to local storage
       */
      function save_options() {
        for(key in options) {
          widget.preferences.setItem(key,JSON.stringify(options[key]));
        }
      }
      
      load_options();
    </script>
  </head>
  <body>
  </body>
</html>
